#include <stdio.h>
#include <string.h>

#define _CRT_SECURE_NO_WARNINGS

int main() {

	int Quiz1 = 0; // 10진수를 입력받을 변수, 부호가 없는 경우 2진수 계산
	int Quiz1_1 = 0; // 부호가 있는 경우 2진수를 계산하기 위해 입력받은 Quiz1 값을 저장해준다
	int Quiz1_16 = 0; // 부호가 없는 경우 16진수를 계산하기 위해 입력받은 Quiz1 값을 저장해준다
	int Quiz1_16_1 = 0; // 부호가 있는 경우 16진수를 계산하기 위해 입력받은 Quiz1 값을 저장해준다

	int arr[20] = { 0, }; // 2진수 값을 저장할 배열
	int arr2[20] = { 0 , }; // 2의 보수 값을 저장할 배열
	char string[20] = { 0, }; // 16진수의 값을 저장할 배열

	int a = 0; // 2진수값을 저장할 배열의 인덱스값을 조절할 변수
	int b = 0; // 2의 보수를 저장할 배열의 인덱스값을 조절할 변수
	int c = 0; // 16진수 값을 저장할 배열의 인덱스값을 조절할 변수
	int k = 0; // 16진수를 계산할 때 나머지 값을 담기위해 사용하는 변수
	int z = 0; // 부호가 없는 경우 2진수 값을 저장하는 배열의 인덱스 값
	int mask; // 2진수 값을 구하기 위한 반복문에 사용
	int result = 0; // 2진수 값을 하나하나 저장하기 위해 임시로 값을 담는 변수
	int num = 7;

	printf("1번 문제, 10진수 정수를 입력하세요: ");
	scanf_s("%d", &Quiz1);

	Quiz1_1 = Quiz1;
	Quiz1_16 = Quiz1;
	Quiz1_16_1 = Quiz1;

	if (Quiz1 < 0) { // 입력받은 수가 음수라면 부호가 없는 경우를 구하기 위해 양수로 바꿔준다
		Quiz1 = -Quiz1;
		Quiz1_16 = -Quiz1_16;
	}

	printf("\n부호가 없는 경우 2진수: ");
	for (int i = 7; i >= 0; i--) { // 2진수 값을 하나씩 출력
		mask = 1 << i;
		result = (Quiz1 & mask) ? 1 : 0; // 2진수 값을 배열에 저장하기 위해 한 개씩 result에 저장한다
		arr[z++] = result; // 배열에 저장한다

		printf("%d", result); // 출력한다

		if (z == 4) { // 보기 편하게 중간에 띄어쓰기 한 번 해준다
			printf(" ");
		}
	}

	printf("\n부호가 없는 경우 16진수: ");
	while (1) { // 16진수 값을 구하기 위한 반복문
		k = Quiz1_16 % 16; // 16으로 나누었을 때 나머지를 구함

		if (k < 10) { // 나머지가 10보다 작으면 숫자 0의 ASCII 코드 값 48과 나머지를 더함
			string[c] = 48 + k;
		}
		else { // 나머지가 10보다 크거나 같으면 나머지에서 10을 뺀 값과 대문자 A의 ASCII 코드 값 65를 더함			
			string[c] = 65 + (k - 10);
		}

		Quiz1_16 = Quiz1_16 / 16; // Quiz1_16을 16으로 나누고 몫을 Quiz1_16에 저장

		c++; // 16진수 값을 저장하는 배열의 인덱스 값을 하나 증가

		if (Quiz1_16 == 0) // 다 나누고 0이 되면 반복문 탈출
			break;
	}
	for (int i = c - 1; i >= 0; i--) { // 16진수 값을 출력하기 위한 반복문(역순)
		printf("%c", string[i]);
	}

	k = 0; // 부호가 없는 경우에서 사용했으므로 다시 0으로 초기화해준다
	c = 0; // 부호가 없는 경우에서 사용했으므로 다시 0으로 초기화해준다

	// 부호가 있는 경우
	if (Quiz1_1 > 0) { // 양수일 경우
		printf("\n부호가 있는 경우 2진수: ");
		for (int i = 7; i >= 0; i--) { // 2진수 값을 구하는 반복문(부호가 없는 경우와 동일)
			mask = 1 << i;
			printf("%d", Quiz1_1 & mask ? 1 : 0);

			if (i == 4) { // 보기 편하게 중간에 한 번 띄어준다
				printf(" ");
			}
		}

		printf("\n부호가 있는 경우 16진수: ");
		while (1) { // 16진수 값을 구하기 위한 반복문
			k = Quiz1_16_1 % 16; // 16으로 나누었을 때 나머지를 구함

			if (k < 10) { // 나머지가 10보다 작으면 숫자 0의 ASCII 코드 값 48과 나머지를 더함
				string[c] = 48 + k;
			}
			else { // 나머지가 10보다 크거나 같으면 나머지에서 10을 뺀 값과 대문자 A의 ASCII 코드 값 65를 더함			
				string[c] = 65 + (k - 10);
			}

			Quiz1_16_1 = Quiz1_16_1 / 16; // Quiz1을 16으로 나누고 몫을 Quiz1에 저장

			c++;

			if (Quiz1_16_1 == 0)
				break;
		}
		for (int i = c - 1; i >= 0; i--) { // 16진수 값을 출력하기 위한 반복문(역순)
			printf("%c", string[i]);
		}
		printf("\n");
	}

	else if (Quiz1_1 < 0) { // 음수일 경우
		printf("\n부호가 있는 경우 2진수: ");
		for (int i = 0; i < 8; i++) { // 1의 보수로 전환하기 위한 반복문, arr배열에 담았던 2진수 값들을 arr2배열에 1의 보수로 저장한다
			if (arr[i] == 0) { // 0이면 1로 바꿔준다
				arr2[b++] = 1;
			}
			else if (arr[i] == 1) { // 1이면 0으로 바꿔준다
				arr2[b++] = 0;
			}
		}

		arr2[7] = arr2[7] + 1; // 1의 보수 값을 구한 후 +1
		while (1) { // 캐리가 발생했을 경우 반복문
			if (arr2[num] > 1) { // 마지막에 +1을 했는데 마지막 수가 2가 될 경우
				arr2[num] = 0; // 0으로 바꿔주고
				arr2[num - 1] = arr2[num - 1] + 1; // 다음 자리에 1을 더해준다
			}
			a--; // 이 과정을 반복

			if (a == -1) { // 과정을 마치면 반복문 탈출
				break;
			}
		}

		for (int i = 0; i < 8; i++) { // 2의 보수 값을 저장한 arr2배열을 차례로 출력하는 반복문
			printf("%d", arr2[i]);

			if (i == 3) { // 보기 편하게 중간에 한 번 띄어준다
				printf(" ");
			}
		}
		printf("\n부호가 있는 경우 16진수: ");
		printf("%X\n", Quiz1_16_1);
	}

	return 0;
}